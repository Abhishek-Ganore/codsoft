# -*- coding: utf-8 -*-
"""Copy of titanic_survival_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r2TJKfwhrWrQdWjtI6-hxNUfAVioHGGf
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression  # Corrected the class name
from sklearn.metrics import accuracy_score  # Corrected 'metrices' to 'metrics'
r̥r̥r̥r̥
# Example dataset creation
# For demonstration, let's create a simple synthetic dataset
from sklearn.datasets import make_classification

# Create a synthetic dataset
X, y = make_classification(n_samples=1000, n_features=20, n_classes=2, random_state=42)

# Convert to DataFrame for easier manipulation
df = pd.DataFrame(X, columns=[f'feature_{i}' for i in range(20)])
df['target'] = y

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(df.drop('target', axis=1), df['target'], test_size=0.2, random_state=42)

# Initialize and train the logistic regression model
model = LogisticRegression(max_iter=1000)  # Increased max_iter to ensure convergence
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')

# Optional: Visualize feature importance (coefficients)
coefficients = model.coef_[0]
features = df.drop('target', axis=1).columns

# Create a bar plot of feature importance
plt.figure(figsize=(10, 6))
sns.barplot(x=coefficients, y=features)
plt.title('Feature Importance from Logistic Regression')
plt.xlabel('Coefficient Value')
plt.ylabel('Features')
plt.show()

"""Data collection/loading and processing"""

titanic_data = pd.read_csv('/content/train.csv')

titanic_data.head()

titanic_data.shape

titanic_data.info()

titanic_data.isnull().sum()

#remove missing/null values
titanic_data = titanic_data.drop(columns='Cabin',axis=1)

#replacing missing valueswith mean number
titanic_data['age'].fillna(titanic_data['age'].mean(), inplace=True)

titanic_data.info()

titanic_data.isnull().sum()

titanic_data.describe()

#how many survives?
# Check if 'Survived' column exists
if 'Survived' in titanic_data.columns:
    survived_counts = titanic_data['Survived'].value_counts()
    print(survived_counts)
else:
    print("Column 'Survived' not found in the DataFrame.")
    # Check for other potential column names like 'survived', 'Survival', etc.
    print("Available columns:", titanic_data.columns)

#visual90izing data
sns.set

# Change 'survived' to 'Survived' in your countplot call
sns.countplot(x='Survived', data=titanic_data)

titanic_data['Sex'].value_counts() # Change 'sex' to 'Sex'

#count plot for "sex" column
sns.countplot(x='Sex', data=titanic_data)  # Change 'sex' to 'Sex'

#nalysing gender wise survivors
sns.countplot(x='Sex', hue='Survived', data=titanic_data)

#count plot for "pclass" column
sns.countplot(x='Pclass', hue='Survived', data=titanic_data) # Change 'survived' to 'Survived'

sns.countplot(x='Pclass', hue='Survived', data=titanic_data) # Change 'survived' to 'Survived'

"""Encoding the catagorical data"""

titanic_data['Sex'].value_counts()

titanic_data['Embarked'].value_counts()

titanic_data.replace({'Sex':{'male':0,'female':1}, 'Embarked':{'S':0,'C':1,'Q':2}})

x = titanic_data.drop(columns = ['PassengerId','Name','Ticket','Survived'],axis=1)
y = titanic_data['Survived']

print(x)

print(y)

"""split data into test data and train data"""

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=2)

print(x.shape,x_train.shape,x_test.shape)

"""logistical regression and model training"""

# Import the necessary class from the sklearn module
from sklearn.linear_model import LogisticRegression

# Now you can create an instance of the LogisticRegression class
model = LogisticRegression()

"""use the train data on logistic regressio  model

"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.datasets import make_classification

# Create a synthetic dataset
X, y = make_classification(n_samples=1000, n_features=20, n_classes=2, random_state=42)

# Convert to DataFrame for easier manipulation
df = pd.DataFrame(X, columns=[f'feature_{i}' for i in range(20)])
df['target'] = y

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(df.drop('target', axis=1), df['target'], test_size=0.2, random_state=42)

# Initialize and train the logistic regression model
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)  # Ensure y_train is lowercase

# Make predictions
y_pred = model.predict(X_test)

# Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')

# Optional: Visualize feature importance (coefficients)
coefficients = model.coef_[0]
features = df.drop('target', axis=1).columns

# Create a bar plot of feature importance
plt.figure(figsize=(10, 6))
sns.barplot(x=coefficients, y=features)
plt.title('Feature Importance from Logistic Regression')
plt.xlabel('Coefficient Value')
plt.ylabel('Features')
plt.show()

#evaluating and testing the model

x_train_prediction = model.predict(X_train)  # Changed x_train to X_train

print(x_train_prediction)

training_data_accuracy = accuracy_score(y_train,x_train_prediction)
print('Accuracy score of the training data : ', training_data_accuracy)

#chech accuracy of test data
x_train_prediction = model.predict(X_test)  # Changed x_train to X_train

print(x_train_prediction)

test_data_accuracy = accuracy_score(y_test,x_train_prediction)
print('Accuracy score of the test data : ', test_data_accuracy)

#ends  # Added '#' to comment out 'ends'
import joblib
joblib.dump(model,'logistic_regression_model.pkl')

!pip install pyngrok
import subprocess
import os
from pyngrok import ngrok
#setup ngrok
ngrok.set_auth_token("2n3okd9h3afqMkfoiTghhzorFIT_4HygatrymjASrqgiZYHim")

#running flask app
os.system("nohup python -m flask run --no-reload &")

#opening ngrok
# Changed 'popen' to 'Popen' to call the correct subprocess method
proc = subprocess.Popen(["ngrok","http","5000"])

#retrive ngrok's public url here
public_url = ngrok.connect(addr="5000",proto="http")
print("public_URL:",public_url)

from flask import Flask, request, jsonify
from joblib import load
from pyngrok import ngrok
from IPython.display import display, HTML

# Load the trained model
model = load('logistic_regression_model.pkl')

app = Flask(__name__)

@app.route('/')
def home():
    # HTML FORM TO TAKE INPUT
    html_form = """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Titanic Survival Prediction</title>
    </head>
    <body>
        <h2>Titanic Survival Prediction</h2>
        <form id="prediction_form" method="post" action="/predict">
            <label for="pclass">pclass:</label>
            <input type="text" id="pclass" name="pclass"><br><br>

            <label for="sex">sex (0 for male, 1 for female):</label>
            <input type="text" id="sex" name="sex"><br><br>

            <label for="age">age:</label>
            <input type="text" id="age" name="age"><br><br>

            <label for="sibsp">sibsp:</label>
            <input type="text" id="sibsp" name="sibsp"><br><br>

            <label for="parch">parch:</label>
            <input type="text" id="parch" name="parch"><br><br>

            <label for="fare">fare:</label>
            <input type="text" id="fare" name="fare"><br><br>

            <label for="embarked">Embarked (0 for S, 1 for C, 2 for Q):</label>
            <input type="text" id="embarked" name="embarked"><br><br>

            <button type="button" onclick="predictSurvival()">Predict</button>
        </form>

        <p id="prediction_result"></p>

        <script>
            function predictSurvival() {
                var xhr = new XMLHttpRequest();
                var url = "/predict";
                var data = new FormData(document.getElementById("prediction_form"));

                xhr.open("POST", url, true);
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        var response = JSON.parse(xhr.responseText);
                        document.getElementById("prediction_result").textContent = "Prediction: " + response.prediction;
                    }
                };
                xhr.send(data);
            }
        </script>
    </body>
    </html>
    """
    return html_form

@app.route('/predict', methods=['POST'])
def predict():
    # Access form data
    pclass = int(request.form.get('pclass'))
    sex = int(request.form.get('sex'))
    age = float(request.form.get('age'))
    sibsp = int(request.form.get('sibsp'))
    parch = int(request.form.get('parch'))
    fare = float(request.form.get('fare'))
    embarked = int(request.form.get('embarked'))

    # Create a feature vector
    features = [[pclass, sex, age, sibsp, parch, fare, embarked]]
    prediction = model.predict(features)

    return jsonify({'prediction': prediction[0]})

def run_flask_app():
    # Start the Flask app
    app.run(host='127.0.0.1', port=5000, debug=True, use_reloader=False)

# Start ngrok tunnel
ngrok.set_auth_token("YOUR_NGROK_AUTH_TOKEN")  # Replace with your actual token
public_url = ngrok.connect(5000).public_url
print("Public URL:", public_url)

# Display ngrok tunnel URL
display(HTML(f"<h2>Open this link in your browser to access the application:</h2><p>{public_url}</p>"))

try:
    # Keep the Flask app running
    run_flask_app()
except KeyboardInterrupt:
    # Shutdown ngrok and Flask app
    ngrok.kill()